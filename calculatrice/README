Ceci est un exemple de calculatrice 4 opérations + test sur des
nombres entiers avec définitions de fonctions récursives et même
mutuellement récursives et variables globales.

Exemple:
----------------------8<---------------------
#pgcd
mod(x,y)=x - (x/y)*y
abs(x)=x < 0 ? -x : x
gcd(x,y)=
  x=abs(x) y=abs(y)
  x <= y ? gcdaux(x,y) : gcdaux(y,x)
gcdaux(x,y)=x = 0 ? y : gcdaux(mod(y,x),x)

testgcd = gcdaux(42,91)
testgcd = gcdaux(421264322,912356724)
----------------------8<---------------------

Qui affiche lorsqu'on l'éxécute:
----------------------8<---------------------
testgcd = 7
testgcd = 2
----------------------8<--------------------

Cette calculatrice comporte
- un très petit test de la sémantique sans parser
- un interprête et un compilateur:

Pour tout compiler et tester, taper
  ./build.sh

On peut utiliser l'interprêteur en tapant
  ./calc.byte
ou mieux, pour avoir un éditeur de ligne (en installant ledit)
  ledit ./calc.byte
ou encore
  ./calc.byte < calc_tests/test.txt

On lance le compilateur avec
  ./calc.byte -c < calc_tests/test.txt > calc_tests/test.ll

On peut alors compiler:
- llvm vers x86-64
  llc -march=x86-64 calc_tests/test.ll
- compilation de l'assembleur
  as -march=core2 --64 -c calc_tests/test.s -o calc_tests/test.o
- edition de lien
  gcc -march=core2 -m64 calc_tests/test.o -o calc_tests/test.exe

Liste des fichiers:

calc_ast.ml       : l'AST du langage
calc_semantics.ml : la sémantique
calc_parser.ml    : le parser
calc_llvm.ml      : la compilation
llvm.ml/llvm.mli  : interface avec llvm (réutilisable)
calc.ml           : le fichier principal

calc_test_sem.ml  : un test pour les deux premiers fichiers.
